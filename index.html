<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lightning Wars - Zeus Duel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, deleteDoc, getDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ==========================================
        //  FIREBASE CONFIGURATION
        // ==========================================
        const myPersonalConfig = {
            apiKey: "AIzaSyCNFhph9nTvshmrp1nuJC1o53TD-Nknhb8",
            authDomain: "lightning-wars.firebaseapp.com",
            projectId: "lightning-wars",
            storageBucket: "lightning-wars.firebasestorage.app",
            messagingSenderId: "982497742304",
            appId: "1:982497742304:web:b04c2e6670950f8f052f85",
            measurementId: "G-07B7389H3N"
        };

        let app, auth, db;
        const envConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const finalConfig = myPersonalConfig || envConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'lightning-wars-v1';
        
        if (finalConfig) {
            try {
                app = initializeApp(finalConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            } catch (e) {
                console.error("Firebase config error:", e);
            }
        }

        // --- Game Constants & State ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 450;
        const MAX_HEALTH = 5;
        const BOLT_SPEED = 8;
        const MOVE_SPEED = 5;
        const JUMP_FORCE = -15;
        const GRAVITY = 0.8;

        let gameState = {
            mode: 'menu', 
            roomId: '',
            role: null, 
            playerName: '',
            userId: null,
            players: {
                p1: { name: 'Zeus 1', x: 100, y: 300, vy: 0, health: MAX_HEALTH, score: 0, facing: 1, action: 'idle', ready: false },
                p2: { name: 'Zeus 2', x: 600, y: 300, vy: 0, health: MAX_HEALTH, score: 0, facing: -1, action: 'idle', ready: false }
            },
            bolts: [],
            isBot: true,
            round: 1,
            winner: null,
            lastHandledBoltId: null,
            opponentJoined: false
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const uiScreens = ['menu', 'nameEntry', 'matchmaking', 'challenge', 'hud', 'mobileControls'];
        function showScreen(screenId) {
            uiScreens.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (id === screenId || (screenId === 'playing' && (id === 'hud' || id === 'mobileControls'))) {
                        el.classList.remove('hidden');
                    } else {
                        // Keep mobile controls always visible if on mobile
                        if (id === 'mobileControls' && window.innerWidth < 800 && (gameState.mode === 'playing' || gameState.mode === 'challenge')) {
                             el.classList.remove('hidden');
                        } else {
                             el.classList.add('hidden');
                        }
                    }
                }
            });
        }

        async function init() {
            if (auth) {
                try {
                    const isUsingEnvConfig = !myPersonalConfig && !!envConfig;
                    if (isUsingEnvConfig && typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                    onAuthStateChanged(auth, (user) => {
                        if (user) gameState.userId = user.uid;
                    });
                } catch (err) {
                    console.error("Auth error:", err);
                    try { await signInAnonymously(auth); } catch(e) {}
                }
            }
            requestAnimationFrame(gameLoop);
        }

        window.goToNameEntry = () => {
            gameState.isBot = false;
            showScreen('nameEntry');
        };

        window.submitName = () => {
            const name = document.getElementById('userNameInput').value.trim();
            if (!name) return alert("Please enter a name!");
            gameState.playerName = name;
            startMatchmaking();
        };

        async function startMatchmaking() {
            if (!db) return alert("Database not connected!");
            gameState.mode = 'matchmaking';
            showScreen('matchmaking');
            
            const matchmakingRef = doc(db, 'artifacts', appId, 'public', 'data', 'matchmaking', 'global_queue');
            
            try {
                const snap = await getDoc(matchmakingRef);
                const data = snap.exists() ? snap.data() : null;

                // If a room is in the queue and it's fresh (created in the last 15 seconds)
                if (data && data.roomId && (Date.now() - data.timestamp < 15000)) {
                    const rId = data.roomId;
                    await setDoc(matchmakingRef, { roomId: null, timestamp: Date.now() });
                    joinRoom(rId, 'p2');
                } else {
                    const rId = "room_" + Math.random().toString(36).substr(2, 9);
                    await setDoc(matchmakingRef, { roomId: rId, timestamp: Date.now() });
                    joinRoom(rId, 'p1');
                }
            } catch (e) {
                console.error("Matchmaking error:", e);
                joinRoom("fallback_arena", 'p1');
            }
        }

        async function joinRoom(id, role) {
            gameState.roomId = id;
            gameState.role = role;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id);
            
            if (role === 'p1') {
                gameState.players.p1.name = gameState.playerName;
                await setDoc(roomRef, {
                    p1: gameState.userId,
                    p2: null,
                    state: gameState.players,
                    lastBolt: null,
                    timestamp: Date.now()
                });
            } else {
                gameState.players.p2.name = gameState.playerName;
                await updateDoc(roomRef, { 
                    p2: gameState.userId,
                    'state.p2.name': gameState.playerName,
                    'state.p2.ready': false
                });
            }

            onSnapshot(roomRef, (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                gameState.opponentJoined = !!(data.p1 && data.p2);
                const otherRole = gameState.role === 'p1' ? 'p2' : 'p1';
                const myRole = gameState.role;

                if (data.state) {
                    // Sync Opponent completely
                    if (data.state[otherRole]) {
                        gameState.players[otherRole] = { ...gameState.players[otherRole], ...data.state[otherRole] };
                    }
                    // Sync My Meta-States (Score, Ready, but NOT Health/Position which I control)
                    if (data.state[myRole]) {
                        gameState.players[myRole].score = data.state[myRole].score;
                        gameState.players[myRole].ready = data.state[myRole].ready;
                        // Important: Only sync health from DB if it's strictly necessary (e.g., initial load)
                        // but normally local is the authority.
                    }
                }

                if (data.lastBolt && data.lastBolt.owner !== gameState.role && data.lastBolt.id !== gameState.lastHandledBoltId) {
                    spawnBolt(data.lastBolt.owner, data.lastBolt.x, data.lastBolt.y, data.lastBolt.dir);
                    gameState.lastHandledBoltId = data.lastBolt.id;
                }

                if (gameState.opponentJoined) {
                    if (gameState.players.p1.ready && gameState.players.p2.ready) {
                        if (gameState.mode !== 'playing') showScreen('playing');
                        gameState.mode = 'playing';
                    } else {
                        if (gameState.mode !== 'challenge') {
                            showScreen('challenge');
                            document.getElementById('oppName').innerText = gameState.players[otherRole].name;
                        }
                        gameState.mode = 'challenge';
                    }
                }
            });
        }

        window.acceptChallenge = () => {
            if (!gameState.role) return;
            gameState.players[gameState.role].ready = true;
            syncMyState();
        };

        function syncMyState() {
            if (!db || !gameState.roomId || !gameState.role) return;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', gameState.roomId);
            const p = gameState.players[gameState.role];
            
            updateDoc(roomRef, {
                [`state.${gameState.role}.x`]: p.x,
                [`state.${gameState.role}.y`]: p.y,
                [`state.${gameState.role}.health`]: p.health, 
                [`state.${gameState.role}.action`]: p.action,
                [`state.${gameState.role}.facing`]: p.facing,
                [`state.${gameState.role}.score`]: p.score,
                [`state.${gameState.role}.ready`]: p.ready
            });
        }

        function syncBolt(x, y, dir) {
            if (!db || !gameState.roomId) return;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', gameState.roomId);
            updateDoc(roomRef, {
                lastBolt: { id: Math.random().toString(36), owner: gameState.role, x, y, dir }
            });
        }

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function spawnBolt(owner, x, y, dir) {
            gameState.bolts.push({ owner, x, y, dir, active: true });
        }

        function handleInput() {
            if (gameState.mode !== 'playing') return;
            const roleKey = gameState.isBot ? 'p1' : (gameState.role || 'p1');
            const p = gameState.players[roleKey];
            
            let moved = false;
            if (keys['ArrowLeft']) { p.x -= MOVE_SPEED; p.facing = -1; moved = true; }
            if (keys['ArrowRight']) { p.x += MOVE_SPEED; p.facing = 1; moved = true; }
            if (keys['ArrowUp'] && p.y >= 300) { p.vy = JUMP_FORCE; moved = true; }
            
            if (keys['Space'] && !p.cooldown) {
                spawnBolt(roleKey, p.x + (p.facing * 20), p.y + 20, p.facing);
                if (!gameState.isBot) syncBolt(p.x, p.y, p.facing);
                p.cooldown = true;
                setTimeout(() => p.cooldown = false, 600);
            }

            p.action = (keys['ArrowLeft'] || keys['ArrowRight']) ? 'move' : 'idle';
            if (p.y < 300) p.action = 'jump';
            p.x = Math.max(0, Math.min(CANVAS_WIDTH - 40, p.x));
            
            if (moved && !gameState.isBot) syncMyState();
        }

        function updateBot() {
            if (!gameState.isBot) return;
            const bot = gameState.players.p2;
            const target = gameState.players.p1;
            if (bot.x < target.x - 180) { bot.x += 3; bot.facing = 1; }
            else if (bot.x > target.x + 180) { bot.x -= 3; bot.facing = -1; }
            if (Math.random() < 0.02 && !bot.cooldown) {
                spawnBolt('p2', bot.x + (bot.facing * 20), bot.y + 20, bot.facing);
                bot.cooldown = true;
                setTimeout(() => bot.cooldown = false, 800);
            }
            if (Math.random() < 0.01 && bot.y >= 300) bot.vy = JUMP_FORCE;
        }

        function update() {
            if (gameState.mode !== 'playing') return;

            ['p1', 'p2'].forEach(key => {
                const p = gameState.players[key];
                p.y += p.vy;
                if (p.y < 300) p.vy += GRAVITY;
                else { p.y = 300; p.vy = 0; }
            });

            gameState.bolts.forEach((bolt) => {
                bolt.x += bolt.dir * BOLT_SPEED;
                const targetKey = bolt.owner === 'p1' ? 'p2' : 'p1';
                const target = gameState.players[targetKey];

                // Improved hit detection area (center of Zeus character)
                const charCenterX = target.x + 20;
                const charCenterY = target.y + 30;
                const hitBoxRadius = 35;

                const dx = bolt.x - charCenterX;
                const dy = (bolt.y) - charCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (bolt.active && distance < hitBoxRadius) {
                    // Bolt hit a player
                    bolt.active = false; // BOLT DISAPPEARS FOR EVERYONE

                    if (gameState.isBot) {
                        target.health--;
                        checkRoundEnd();
                    } else if (targetKey === gameState.role) {
                        // LOCAL AUTHORITY: Only I can take damage for myself
                        gameState.players[gameState.role].health--;
                        console.log("Took damage! New health:", gameState.players[gameState.role].health);
                        syncMyState(); // Update health in DB immediately
                        checkRoundEnd();
                    }
                }

                if (bolt.x < -50 || bolt.x > CANVAS_WIDTH + 50) bolt.active = false;
            });
            gameState.bolts = gameState.bolts.filter(b => b.active);

            handleInput();
            if (gameState.isBot) updateBot();
        }

        function checkRoundEnd() {
            if (gameState.players.p1.health <= 0 || gameState.players.p2.health <= 0) {
                const winner = gameState.players.p1.health <= 0 ? 'p2' : 'p1';
                gameState.players[winner].score++;
                if (gameState.players[winner].score >= 2) {
                    gameState.mode = 'gameover';
                    gameState.winner = winner;
                } else {
                    resetRound();
                }
            }
        }

        function resetRound() {
            gameState.players.p1.health = MAX_HEALTH;
            gameState.players.p2.health = MAX_HEALTH;
            gameState.players.p1.x = 100;
            gameState.players.p2.x = 600;
            gameState.players.p1.vy = 0;
            gameState.players.p2.vy = 0;
            gameState.bolts = [];
            gameState.round++;
            if (!gameState.isBot) syncMyState();
        }

        function drawZeus(p, color) {
            ctx.save();
            ctx.translate(p.x + 20, p.y + 30);
            if (p.facing === -1) ctx.scale(-1, 1);
            
            // Name tag
            ctx.scale(p.facing === -1 ? -1 : 1, 1);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(p.name || 'Player', 0, -50);
            if (p.facing === -1) ctx.scale(-1, 1);

            // Toga
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-15, 30); ctx.lineTo(15, 30); ctx.lineTo(10, -10); ctx.lineTo(-10, -10);
            ctx.fill();
            // Head
            ctx.fillStyle = '#f3e5ab';
            ctx.beginPath(); ctx.arc(0, -25, 12, 0, Math.PI * 2); ctx.fill();
            // Beard
            ctx.fillStyle = '#fff'; 
            ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(10, -20); ctx.lineTo(0, 0); ctx.fill();
            
            // Glow border
            ctx.shadowBlur = 15; ctx.shadowColor = color; ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.strokeRect(-20, -40, 40, 70);
            ctx.restore();
        }

        function drawBolt(bolt) {
            ctx.save();
            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = '#0ff';
            ctx.beginPath();
            let bx = bolt.x; let by = bolt.y;
            ctx.moveTo(bx, by);
            for(let i=0; i<5; i++) { 
                bx += bolt.dir * 10; 
                by += (Math.random() - 0.5) * 20; 
                ctx.lineTo(bx, by); 
            }
            ctx.stroke();
            ctx.restore();
        }

        function draw() {
            const grad = ctx.createLinearGradient(0,0,0,CANVAS_HEIGHT);
            grad.addColorStop(0, '#001'); grad.addColorStop(1, '#112');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Floor
            ctx.fillStyle = '#223';
            ctx.fillRect(0, 360, CANVAS_WIDTH, 90);

            if (gameState.mode === 'playing' || gameState.mode === 'challenge' || gameState.mode === 'gameover') {
                drawZeus(gameState.players.p1, '#0af');
                drawZeus(gameState.players.p2, '#f0a');
                gameState.bolts.forEach(drawBolt);

                document.getElementById('p1-health').style.width = (gameState.players.p1.health / MAX_HEALTH * 100) + '%';
                document.getElementById('p2-health').style.width = (gameState.players.p2.health / MAX_HEALTH * 100) + '%';
                document.getElementById('p1-name-display').innerText = gameState.players.p1.name;
                document.getElementById('p2-name-display').innerText = gameState.players.p2.name;
                document.getElementById('round-text').innerText = `Round ${gameState.round} | Score: ${gameState.players.p1.score} - ${gameState.players.p2.score}`;
            }

            if (gameState.mode === 'gameover') {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px sans-serif'; ctx.textAlign = 'center';
                ctx.fillText(`${gameState.players[gameState.winner].name} WINS!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
                ctx.font = '20px sans-serif'; ctx.fillText('Click to restart', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.startBotGame = () => { 
            gameState.isBot = true; 
            gameState.players.p1.name = "You";
            gameState.players.p2.name = "Bot";
            gameState.mode = 'playing';
            showScreen('playing');
        };

        window.handleMove = (dir) => { 
            if (dir === 0) { keys['ArrowLeft'] = false; keys['ArrowRight'] = false; }
            else if (dir === -1) { keys['ArrowLeft'] = true; keys['ArrowRight'] = false; }
            else if (dir === 1) { keys['ArrowLeft'] = false; keys['ArrowRight'] = true; }
        };
        window.handleJump = () => { keys['ArrowUp'] = true; setTimeout(() => keys['ArrowUp'] = false, 100); };
        window.handleShoot = () => { keys['Space'] = true; setTimeout(() => keys['Space'] = false, 100); };
        canvas.onclick = () => { if (gameState.mode === 'gameover') location.reload(); };
        window.onload = init;
    </script>
    <style>
        body { background: #000; overflow: hidden; font-family: sans-serif; touch-action: none; }
        #gameCanvas { max-width: 100%; height: auto; display: block; margin: 0 auto; background: #000; border: 4px solid #334; }
        .health-bar { height: 20px; transition: width 0.3s ease; }
        .touch-btn { user-select: none; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="hud" class="hidden w-full max-w-[800px] mb-4 text-white">
        <div class="flex justify-between items-end mb-2">
            <div class="w-1/3">
                <div id="p1-name-display" class="text-xs uppercase opacity-80 mb-1">Player 1</div>
                <div class="bg-gray-800 w-full rounded-full overflow-hidden border border-gray-600">
                    <div id="p1-health" class="health-bar bg-blue-500" style="width: 100%"></div>
                </div>
            </div>
            <div id="round-text" class="text-center font-bold text-xl text-yellow-400">Round 1</div>
            <div class="w-1/3 text-right">
                <div id="p2-name-display" class="text-xs uppercase opacity-80 mb-1">Player 2</div>
                <div class="bg-gray-800 w-full rounded-full overflow-hidden border border-gray-600">
                    <div id="p2-health" class="health-bar bg-pink-500 float-right" style="width: 100%"></div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas" width="800" height="450" class="rounded-xl shadow-2xl shadow-blue-900/20"></canvas>
    
    <!-- Menu -->
    <div id="menu" class="absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-yellow-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <h1 class="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-blue-500 mb-6 italic uppercase tracking-tighter">Lightning Wars</h1>
            <button onclick="startBotGame()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-6 rounded-xl mb-4 shadow-lg shadow-blue-600/20">Play vs Bot</button>
            <button onclick="goToNameEntry()" class="w-full bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-4 px-6 rounded-xl shadow-lg shadow-yellow-500/20">Multiplayer Battle</button>
        </div>
    </div>

    <!-- Name Entry -->
    <div id="nameEntry" class="hidden absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-blue-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <h2 class="text-2xl font-bold text-white mb-4 italic uppercase">Enter Warrior Name</h2>
            <input id="userNameInput" type="text" maxlength="10" placeholder="Zeus Jr" class="w-full bg-gray-800 border border-gray-700 text-white p-4 rounded-xl mb-4 focus:outline-none focus:border-blue-500 text-center uppercase font-bold">
            <button onclick="submitName()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-6 rounded-xl">Enter Arena</button>
        </div>
    </div>

    <!-- Matchmaking -->
    <div id="matchmaking" class="hidden absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-blue-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <div class="animate-spin w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
            <h2 class="text-2xl font-bold text-white mb-2 italic uppercase">Searching...</h2>
            <p class="text-gray-400 text-sm">Looking for a worthy opponent in the clouds.</p>
        </div>
    </div>

    <!-- Challenge UI -->
    <div id="challenge" class="hidden absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-pink-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <h2 class="text-3xl font-black text-white mb-2 italic uppercase tracking-widest text-pink-500">Opponent Found!</h2>
            <p class="text-white text-xl mb-6 font-bold" id="oppName">Opponent</p>
            <button onclick="acceptChallenge()" class="w-full bg-pink-600 hover:bg-pink-500 text-white font-black py-6 px-6 rounded-xl text-2xl animate-pulse">ACCEPT CHALLENGE</button>
            <p class="mt-4 text-xs text-gray-500 uppercase tracking-widest">Both warriors must accept to begin</p>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls" class="hidden fixed bottom-4 left-4 right-4 flex justify-between items-center pointer-events-none">
        <div class="flex gap-2 pointer-events-auto">
            <button ontouchstart="handleMove(-1)" ontouchend="handleMove(0)" class="touch-btn w-16 h-16 bg-white/10 rounded-full flex items-center justify-center border border-white/20 active:bg-white/30 text-2xl text-white">←</button>
            <button ontouchstart="handleMove(1)" ontouchend="handleMove(0)" class="touch-btn w-16 h-16 bg-white/10 rounded-full flex items-center justify-center border border-white/20 active:bg-white/30 text-2xl text-white">→</button>
        </div>
        <div class="flex flex-col gap-2 pointer-events-auto items-end">
            <button ontouchstart="handleJump()" class="touch-btn w-20 h-20 bg-blue-600/50 rounded-full flex items-center justify-center border-2 border-blue-400 active:scale-90 text-white font-bold">JUMP</button>
            <button ontouchstart="handleShoot()" class="touch-btn w-24 h-24 bg-yellow-500/50 rounded-full flex items-center justify-center border-2 border-yellow-400 active:scale-90 text-black font-bold uppercase">Bolt</button>
        </div>
    </div>
</body>
</html>
