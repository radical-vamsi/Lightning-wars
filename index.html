<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lightning Wars - Zeus Duel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ==========================================
        //  FIREBASE CONFIGURATION SECTION
        // ==========================================
        const myPersonalConfig = {
            apiKey: "AIzaSyCNFhph9nTvshmrp1nuJC1o53TD-Nknhb8",
            authDomain: "lightning-wars.firebaseapp.com",
            projectId: "lightning-wars",
            storageBucket: "lightning-wars.firebasestorage.app",
            messagingSenderId: "982497742304",
            appId: "1:982497742304:web:b04c2e6670950f8f052f85",
            measurementId: "G-07B7389H3N"
        };

        let app, auth, db;
        const envConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const finalConfig = myPersonalConfig || envConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'lightning-wars-v1';
        
        if (finalConfig) {
            try {
                app = initializeApp(finalConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                console.log("Firebase initialized successfully.");
            } catch (e) {
                console.error("Firebase config error:", e);
            }
        }

        // --- Game Constants & State ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 450;
        const MAX_HEALTH = 5;
        const BOLT_SPEED = 8;
        const MOVE_SPEED = 5;
        const JUMP_FORCE = -15;
        const GRAVITY = 0.8;

        let gameState = {
            mode: 'menu', 
            roomId: '',
            role: null, 
            playerName: '',
            userId: 'local-user-' + Math.random().toString(36).substr(2, 5),
            players: {
                p1: { name: 'Zeus 1', x: 100, y: 300, vy: 0, health: MAX_HEALTH, score: 0, facing: 1, action: 'idle' },
                p2: { name: 'Zeus 2', x: 600, y: 300, vy: 0, health: MAX_HEALTH, score: 0, facing: -1, action: 'idle' }
            },
            bolts: [],
            isBot: true,
            round: 1,
            winner: null,
            lastHandledBoltId: null,
            opponentJoined: false
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const lobbyEl = document.getElementById('lobby');
        const menuEl = document.getElementById('menu');
        const nameEl = document.getElementById('nameEntry');
        const hudEl = document.getElementById('hud');
        const mobileControls = document.getElementById('mobileControls');

        async function init() {
            if (auth) {
                try {
                    const isUsingEnvConfig = !myPersonalConfig && !!envConfig;
                    if (isUsingEnvConfig && typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                    onAuthStateChanged(auth, (user) => {
                        if (user) gameState.userId = user.uid;
                    });
                } catch (err) {
                    console.error("Auth error:", err);
                    try { await signInAnonymously(auth); } catch(e) {}
                }
            }
            requestAnimationFrame(gameLoop);
        }

        window.submitName = () => {
            const name = document.getElementById('userNameInput').value.trim();
            if (!name) return alert("Please enter a name!");
            gameState.playerName = name;
            nameEl.classList.add('hidden');
            lobbyEl.classList.remove('hidden');
        };

        window.joinRoom = async (id) => {
            if (!id || !db) {
                if (!db) alert("Please set up your Firebase Config in the code to enable Multiplayer!");
                return;
            }
            gameState.roomId = id;
            gameState.isBot = false;
            
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id);
            
            const docSnap = await getDoc(roomRef);
            if (!docSnap.exists()) {
                // I am Player 1
                gameState.role = 'p1';
                gameState.players.p1.name = gameState.playerName;
                await setDoc(roomRef, {
                    p1: gameState.userId,
                    p1Name: gameState.playerName,
                    p2: null,
                    p2Name: null,
                    state: gameState.players,
                    lastBolt: null,
                    timestamp: Date.now()
                });
            } else {
                const data = docSnap.data();
                if (data.p1 === gameState.userId) {
                    gameState.role = 'p1';
                } else {
                    // I am Player 2
                    gameState.role = 'p2';
                    gameState.players.p2.name = gameState.playerName;
                    await updateDoc(roomRef, { 
                        p2: gameState.userId,
                        p2Name: gameState.playerName,
                        'state.p2.name': gameState.playerName
                    });
                }
            }

            onSnapshot(roomRef, (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                // Track if opponent has joined
                gameState.opponentJoined = !!(data.p1 && data.p2);
                
                const otherRole = gameState.role === 'p1' ? 'p2' : 'p1';
                const myRole = gameState.role;

                // Sync Opponent Data
                if (data.state && data.state[otherRole]) {
                    const remoteOpponent = data.state[otherRole];
                    gameState.players[otherRole] = { 
                        ...gameState.players[otherRole], 
                        ...remoteOpponent 
                    };
                }

                // Sync Global Scores & Round (only update my local view)
                if (data.state && data.state[myRole]) {
                    gameState.players[myRole].score = data.state[myRole].score;
                }

                // Handle incoming bolts
                if (data.lastBolt && data.lastBolt.owner !== gameState.role && data.lastBolt.id !== gameState.lastHandledBoltId) {
                    spawnBolt(data.lastBolt.owner, data.lastBolt.x, data.lastBolt.y, data.lastBolt.dir);
                    gameState.lastHandledBoltId = data.lastBolt.id;
                }
            });

            startGame();
        };

        function syncMyState() {
            if (!db || !gameState.roomId || !gameState.role || gameState.role === 'spectator') return;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', gameState.roomId);
            const p = gameState.players[gameState.role];
            
            // Only update MY specific part of the object to avoid overwriting opponent's health changes
            updateDoc(roomRef, {
                [`state.${gameState.role}.x`]: p.x,
                [`state.${gameState.role}.y`]: p.y,
                [`state.${gameState.role}.health`]: p.health,
                [`state.${gameState.role}.action`]: p.action,
                [`state.${gameState.role}.facing`]: p.facing,
                [`state.${gameState.role}.score`]: p.score
            });
        }

        function syncBolt(x, y, dir) {
            if (!db || !gameState.roomId || gameState.role === 'spectator') return;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', gameState.roomId);
            updateDoc(roomRef, {
                lastBolt: { id: Math.random().toString(36), owner: gameState.role, x, y, dir }
            });
        }

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function spawnBolt(owner, x, y, dir) {
            gameState.bolts.push({ owner, x, y, dir, active: true });
        }

        function handleInput() {
            if (gameState.mode !== 'playing' || (!gameState.isBot && !gameState.opponentJoined)) return;
            const roleKey = gameState.isBot ? 'p1' : (gameState.role || 'p1');
            const p = gameState.players[roleKey];
            
            let moved = false;
            if (keys['ArrowLeft']) { p.x -= MOVE_SPEED; p.facing = -1; moved = true; }
            if (keys['ArrowRight']) { p.x += MOVE_SPEED; p.facing = 1; moved = true; }
            if (keys['ArrowUp'] && p.y >= 300) { p.vy = JUMP_FORCE; moved = true; }
            
            if (keys['Space'] && !p.cooldown) {
                spawnBolt(roleKey, p.x + (p.facing * 20), p.y + 20, p.facing);
                if (!gameState.isBot) syncBolt(p.x, p.y, p.facing);
                p.cooldown = true;
                setTimeout(() => p.cooldown = false, 600);
            }

            p.action = moved ? 'move' : 'idle';
            if (p.y < 300) p.action = 'jump';
            p.x = Math.max(0, Math.min(CANVAS_WIDTH - 40, p.x));
            if (moved && !gameState.isBot) syncMyState();
        }

        function updateBot() {
            if (!gameState.isBot) return;
            const bot = gameState.players.p2;
            const target = gameState.players.p1;
            if (bot.x < target.x - 180) { bot.x += 3; bot.facing = 1; }
            else if (bot.x > target.x + 180) { bot.x -= 3; bot.facing = -1; }
            if (Math.random() < 0.02 && !bot.cooldown) {
                spawnBolt('p2', bot.x + (bot.facing * 20), bot.y + 20, bot.facing);
                bot.cooldown = true;
                setTimeout(() => bot.cooldown = false, 800);
            }
            if (Math.random() < 0.01 && bot.y >= 300) bot.vy = JUMP_FORCE;
        }

        function update() {
            if (gameState.mode !== 'playing') return;
            if (!gameState.isBot && !gameState.opponentJoined) return;

            ['p1', 'p2'].forEach(key => {
                const p = gameState.players[key];
                p.y += p.vy;
                if (p.y < 300) p.vy += GRAVITY;
                else { p.y = 300; p.vy = 0; }
            });

            gameState.bolts.forEach((bolt) => {
                bolt.x += bolt.dir * BOLT_SPEED;
                const targetKey = bolt.owner === 'p1' ? 'p2' : 'p1';
                const target = gameState.players[targetKey];

                if (bolt.active && bolt.x > target.x && bolt.x < target.x + 40 && bolt.y > target.y && bolt.y < target.y + 60) {
                    bolt.active = false;
                    
                    if (gameState.isBot) {
                        target.health--;
                        checkRoundEnd();
                    } else if (targetKey === gameState.role) {
                        // ONLY the hit player reduces their own health and syncs
                        target.health--;
                        syncMyState(); 
                        checkRoundEnd();
                    }
                }
                if (bolt.x < -100 || bolt.x > CANVAS_WIDTH + 100) bolt.active = false;
            });
            gameState.bolts = gameState.bolts.filter(b => b.active);

            handleInput();
            if (gameState.isBot) updateBot();
        }

        function checkRoundEnd() {
            if (gameState.players.p1.health <= 0 || gameState.players.p2.health <= 0) {
                const winner = gameState.players.p1.health <= 0 ? 'p2' : 'p1';
                gameState.players[winner].score++;
                if (gameState.players[winner].score >= 2) {
                    gameState.mode = 'gameover';
                    gameState.winner = winner;
                } else {
                    resetRound();
                }
            }
        }

        function resetRound() {
            gameState.players.p1.health = MAX_HEALTH;
            gameState.players.p2.health = MAX_HEALTH;
            gameState.players.p1.x = 100;
            gameState.players.p2.x = 600;
            gameState.players.p1.vy = 0;
            gameState.players.p2.vy = 0;
            gameState.bolts = [];
            gameState.round++;
            if (!gameState.isBot) syncMyState();
        }

        function drawZeus(p, color) {
            ctx.save();
            ctx.translate(p.x + 20, p.y + 30);
            if (p.facing === -1) ctx.scale(-1, 1);
            
            // Draw Name Tag
            ctx.scale(p.facing === -1 ? -1 : 1, 1);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(p.name || 'Player', 0, -50);
            if (p.facing === -1) ctx.scale(-1, 1);

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-15, 30); ctx.lineTo(15, 30); ctx.lineTo(10, -10); ctx.lineTo(-10, -10);
            ctx.fill();
            ctx.fillStyle = '#f3e5ab';
            ctx.beginPath(); ctx.arc(0, -25, 12, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#fff'; 
            ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(10, -20); ctx.lineTo(0, 0); ctx.fill();
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(-20, -40, 40, 70);
            ctx.restore();
        }

        function drawBolt(bolt) {
            ctx.save();
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#0ff';
            ctx.beginPath();
            let bx = bolt.x;
            let by = bolt.y;
            ctx.moveTo(bx, by);
            for(let i=0; i<5; i++) {
                bx += bolt.dir * 10;
                by += (Math.random() - 0.5) * 20;
                ctx.lineTo(bx, by);
            }
            ctx.stroke();
            ctx.restore();
        }

        function draw() {
            const grad = ctx.createLinearGradient(0,0,0,CANVAS_HEIGHT);
            grad.addColorStop(0, '#001');
            grad.addColorStop(1, '#112');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#223';
            ctx.fillRect(0, 360, CANVAS_WIDTH, 90);

            if (gameState.mode === 'playing' || gameState.mode === 'gameover') {
                drawZeus(gameState.players.p1, '#0af');
                drawZeus(gameState.players.p2, '#f0a');
                gameState.bolts.forEach(drawBolt);

                document.getElementById('p1-health').style.width = (gameState.players.p1.health / MAX_HEALTH * 100) + '%';
                document.getElementById('p2-health').style.width = (gameState.players.p2.health / MAX_HEALTH * 100) + '%';
                document.getElementById('p1-name-display').innerText = gameState.players.p1.name;
                document.getElementById('p2-name-display').innerText = gameState.players.p2.name;
                document.getElementById('round-text').innerText = `Round ${gameState.round} | Score: ${gameState.players.p1.score} - ${gameState.players.p2.score}`;

                // Waiting Overlay
                if (!gameState.isBot && !gameState.opponentJoined) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.fillStyle = '#fff';
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Waiting for opponent to join...', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
                    ctx.font = '14px sans-serif';
                    ctx.fillText(`Share Room ID: ${gameState.roomId}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 40);
                }
            }

            if (gameState.mode === 'gameover') {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${gameState.players[gameState.winner].name} WINS!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
                ctx.font = '20px sans-serif';
                ctx.fillText('Click to restart', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.startBotGame = () => { 
            gameState.isBot = true; 
            gameState.players.p1.name = "You";
            gameState.players.p2.name = "Bot";
            startGame(); 
        };

        function startGame() {
            gameState.mode = 'playing';
            menuEl.classList.add('hidden');
            lobbyEl.classList.add('hidden');
            nameEl.classList.add('hidden');
            hudEl.classList.remove('hidden');
            if (window.innerWidth < 800) mobileControls.classList.remove('hidden');
        }

        window.handleMove = (dir) => { 
            if (dir === 0) { keys['ArrowLeft'] = false; keys['ArrowRight'] = false; }
            else if (dir === -1) { keys['ArrowLeft'] = true; keys['ArrowRight'] = false; }
            else if (dir === 1) { keys['ArrowLeft'] = false; keys['ArrowRight'] = true; }
        };
        window.handleJump = () => { keys['ArrowUp'] = true; setTimeout(() => keys['ArrowUp'] = false, 100); };
        window.handleShoot = () => { keys['Space'] = true; setTimeout(() => keys['Space'] = false, 100); };
        canvas.onclick = () => { if (gameState.mode === 'gameover') location.reload(); };
        window.onload = init;
    </script>
    <style>
        body { background: #000; overflow: hidden; font-family: sans-serif; touch-action: none; }
        #gameCanvas { max-width: 100%; height: auto; display: block; margin: 0 auto; background: #000; border: 4px solid #334; }
        .health-bar { height: 20px; transition: width 0.3s ease; }
        .touch-btn { user-select: none; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="hud" class="hidden w-full max-w-[800px] mb-4 text-white">
        <div class="flex justify-between items-end mb-2">
            <div class="w-1/3">
                <div id="p1-name-display" class="text-xs uppercase opacity-80 mb-1">Player 1</div>
                <div class="bg-gray-800 w-full rounded-full overflow-hidden border border-gray-600">
                    <div id="p1-health" class="health-bar bg-blue-500" style="width: 100%"></div>
                </div>
            </div>
            <div id="round-text" class="text-center font-bold text-xl text-yellow-400">Round 1</div>
            <div class="w-1/3 text-right">
                <div id="p2-name-display" class="text-xs uppercase opacity-80 mb-1">Player 2</div>
                <div class="bg-gray-800 w-full rounded-full overflow-hidden border border-gray-600">
                    <div id="p2-health" class="health-bar bg-pink-500 float-right" style="width: 100%"></div>
                </div>
            </div>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="450" class="rounded-xl shadow-2xl shadow-blue-900/20"></canvas>
    
    <!-- Menu Screen -->
    <div id="menu" class="absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-yellow-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl shadow-yellow-500/10">
            <h1 class="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-blue-500 mb-6 italic uppercase tracking-tighter">Lightning Wars</h1>
            <p class="text-gray-400 mb-8">Master the power of Zeus. Duel with friends or test your skills against AI.</p>
            <button onclick="startBotGame()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-6 rounded-xl mb-4 transition transform active:scale-95 shadow-lg shadow-blue-600/20">Play vs Bot</button>
            <button onclick="document.getElementById('menu').classList.add('hidden'); document.getElementById('nameEntry').classList.remove('hidden')" class="w-full bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-4 px-6 rounded-xl transition transform active:scale-95 shadow-lg shadow-yellow-500/20">Multiplayer Lobby</button>
        </div>
    </div>

    <!-- Name Entry Screen -->
    <div id="nameEntry" class="hidden absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-blue-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <h2 class="text-2xl font-bold text-white mb-4">Enter Your Name</h2>
            <input id="userNameInput" type="text" maxlength="10" placeholder="Your Zeus Name" class="w-full bg-gray-800 border border-gray-700 text-white p-4 rounded-xl mb-4 focus:outline-none focus:border-blue-500 text-center">
            <button onclick="submitName()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-6 rounded-xl mb-4">Continue</button>
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby" class="hidden absolute inset-0 z-10 flex items-center justify-center bg-black/80 p-6">
        <div class="bg-gray-900 border-2 border-blue-500 p-8 rounded-2xl text-center max-w-sm w-full shadow-2xl">
            <h2 class="text-2xl font-bold text-white mb-4">Multiplayer Lobby</h2>
            <p class="text-gray-400 mb-6 text-sm">Enter a Room ID and share it with a friend!</p>
            <input id="roomInput" type="text" placeholder="Room ID" class="w-full bg-gray-800 border border-gray-700 text-white p-4 rounded-xl mb-4 focus:outline-none focus:border-blue-500 text-center uppercase">
            <button onclick="joinRoom(document.getElementById('roomInput').value.toUpperCase())" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-6 rounded-xl mb-4">Join Battle</button>
            <button onclick="document.getElementById('lobby').classList.add('hidden'); document.getElementById('menu').classList.remove('hidden')" class="text-gray-500 text-sm underline">Back to Menu</button>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls" class="hidden fixed bottom-4 left-4 right-4 flex justify-between items-center pointer-events-none">
        <div class="flex gap-2 pointer-events-auto">
            <button ontouchstart="handleMove(-1)" ontouchend="handleMove(0)" class="touch-btn w-16 h-16 bg-white/10 rounded-full flex items-center justify-center border border-white/20 active:bg-white/30 text-2xl text-white">←</button>
            <button ontouchstart="handleMove(1)" ontouchend="handleMove(0)" class="touch-btn w-16 h-16 bg-white/10 rounded-full flex items-center justify-center border border-white/20 active:bg-white/30 text-2xl text-white">→</button>
        </div>
        <div class="flex flex-col gap-2 pointer-events-auto items-end">
            <button ontouchstart="handleJump()" class="touch-btn w-20 h-20 bg-blue-600/50 rounded-full flex items-center justify-center border-2 border-blue-400 active:scale-90 text-white font-bold">JUMP</button>
            <button ontouchstart="handleShoot()" class="touch-btn w-24 h-24 bg-yellow-500/50 rounded-full flex items-center justify-center border-2 border-yellow-400 active:scale-90 text-black font-bold">BOLT</button>
        </div>
    </div>
</body>
</html>
